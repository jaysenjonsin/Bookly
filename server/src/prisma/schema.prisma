// to format file: in src folder, run npx prisma format
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"] //allows use of multiple postgres schemas --> using since we are using "social" schema instead of default "public"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public", "social"]
}

//NOTE: when modifying schema, make sure to run npx prisma generate after to generate a version of prisma client tailored to models - better autocomplete

model User {
  id          Int            @id @default(autoincrement()) //@id: pk
  username    String         @unique @db.VarChar(50) //just putting String -> prisma defaults to text data type. @db.VarChar changes to varchar
  email       String         @unique @db.VarChar(45)
  password    String         @db.VarChar(400)
  name        String         @db.VarChar(50)
  cover_pic   String?        @db.VarChar(200)
  profile_pic String?        @db.VarChar(200)
  city        String?        @db.VarChar(50)
  website     String?        @db.VarChar(50)
  created_at  DateTime       @default(now()) //SQL generated is TIMESTAMP(3), meaning this is of data type timestamp with 3 decimal precision
  updated_at  DateTime       @updatedAt
  posts       Post[]
  comments    Comment[]
  stories     Story[]
  likes       Like[]
  followers   Relationship[] @relation("follower") //normally wouldnt have to put @relation field for m to n, but since this m to n is user to user we have to specify which relation is which
  followed    Relationship[] @relation("followed")

  @@map("users") //even though are model is named User, we can name our table in db users
  @@schema("social")
}

model Post {
  id         Int       @id @default(autoincrement())
  desc       String    @db.VarChar(400)
  img        String?   @db.VarChar(400)
  user_id    Int
  user       User      @relation(fields: [user_id], references: [id], onDelete: Cascade) //user id field references id in User
  // prisma sets ON DELETE to RESTRICT by default
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  comments   Comment[]
  likes      Like[]

  @@map("posts")
  @@schema("social")
}

model Comment {
  id         Int      @id @default(autoincrement())
  desc       String   @db.VarChar(400)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  user_id    Int
  post_id    Int
  Post       Post     @relation(fields: [post_id], references: [id], onDelete: Cascade) //when post is deleted, delete comment
  User       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  likes      Like[]

  @@map("comments")
  @@schema("social")
}

model Story {
  id      Int    @id @default(autoincrement())
  img     String @db.VarChar(400)
  user_id Int
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("stories")
  @@schema("social")
}

//join table for "User" and "User" : follower and following relationship
model Relationship {
  id               Int  @id @default(autoincrement())
  follower_user_id Int
  followed_user_id Int
  follower         User @relation("follower", fields: [follower_user_id], references: [id], onDelete: Cascade) //normally wouldnt have to put "name" before fields:[] for m to n, but since this m to n is user to user we have to specify which relation is which
  followed         User @relation("followed", fields: [followed_user_id], references: [id], onDelete: Cascade)

  @@map("relationships")
  //@@id([follower_user_id, followed_user_id]) //unique pkey generated by combo of id's
  @@schema("social")
}

model Like {
  id         Int     @id @default(autoincrement())
  user_id    Int
  post_id    Int
  comment_id Int
  user       User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  post       Post    @relation(fields: [post_id], references: [id], onDelete: Cascade)
  comment    Comment @relation(fields: [comment_id], references: [id], onDelete: Cascade)

  @@map("likes")
  @@schema("social")
}
