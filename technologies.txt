--MAIN TECHNOLOGIES--

-backend-
  -TypeScript
  -Node/Express
  -PostGres
  -Redis
  -Prisma

-frontend-
  -TypeScript
  -React
  -NextJS
  -SCSS
  -React-Hook-Form
  -Zod


-------BACK END TECHNOLOGIES-------

----Why use Express?----
  Ease, flexibility, and efficiency: Express is fast, flexible and easy to use due to its lightweight functionality out of the box and middleware-based architecture.
----Why use PostGres?----

----Why use Redis?----
  Performance: Redis is extremely fast due to its in-memory architecture (stores all data in RAM) and key/value storage system, which allows it to store and retrieve data much faster than disk-based databases. This makes it ideal for use cases where speed is critical, such as quick storage/retrieval of a user's session.

-----Why use Prisma?-----
  TypeScript support: Prisma provides TypeScript support out-of-the-box, making it easier to write type-safe code and catch errors at compile-time.

  Easy data modeling: Prisma provides an intuitive data modeling syntax that makes it easy to define the relationships between your data models. For example, all database relations are visible on all prisma models that exist within the relationship, whereas tables in SQL that have foreign keys have no indication of the relation on the table itself.

  Performance: Prisma is designed for performance, with features such as connection pooling, lazy-loading, and batching, which improves the performance of database queries.

  Auto-generated APIs: Prisma generates a strongly-typed API (prismaClient) based on data models, making it easy to interact with your database from your application code.


----Why use backend form validation when already using RHF/Zod to validate forms in the frontend?----
  Front end validation can easily be bypassed. Backend validation is required in order to maintain consistent data that is entered into the database.



-------FRONT END TECHNOLOGIES------- 

---- Why use React?----

  Declarative programming: React encapsulates HTML and JS(structure and functionality) with its component-based architecture, resulting in more declarative code. React code describes what the UI should look like and how it should behave rather than manipulating the DOM directly.

  Components: React's component-based architecture makes it easy to manage and maintain the UI through modularity and reusability.

  Virtual DOM: React's use of the virtual DOM efficiently updates UI in responses to changes in data/state. This results in better performance and responsiveness, as React only updates the parts of the user interface that have actually changed.

----Why use NextJS?----
  Routing: Next.js provides a simple and flexible routing system for my multipage application.

  Built-in optimizations: Next.js includes many built-in optimizations(automatic image optimization, automatic minification of CSS and JavaScript, etc), which improves performance.

  Built-in SSR/SSG: Next.js comes with support for server side rendering(Renders HTML page on the server for each request) and SSG(pre-rendered HTML is served to client upon request), improving initial page load time and SEO for search engines.

----Why use SCSS?----
  Ease and efficiency: SCSS adds several features and enhancements to standard CSS (nesting, easier to use variables, modularity, etc.), making it easier and more efficient to work with.

-----Why use React-Hook-Form / Zod?-----
  Validation: React Hook Form provides a simpler way to handle form validation compared to traditional HTML forms. With React Hook Form, you can define your own custom validation rules and have the errors automatically displayed to the user. Form validation / error handling is made simple through pairing with the Zod schema validation library.

  Performance: React Hook Form is optimized for performance, so it can handle large forms with many inputs more efficiently than traditional HTML forms.

  Accessibility: React Hook Form provides built-in accessibility features, such as automatically adding ARIA attributes to form elements, which can be especially helpful for users with disabilities.

----Why use front end form validation when there is already form validation in the backend?----
  Front end validation can easily be bypassed. The main reasons for front end validation are to reduce load on the server and to improve the user experience by providing feedback to the user on whether their inputs are valid.

